//===-- SPEX64ISelLowering.cpp - SPEX64 DAG lowering --*- C++ -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#include "SPEX64ISelLowering.h"
#include "SPEX64.h"
#include "SPEX64Subtarget.h"
#include "SPEX64TargetMachine.h"
#include "llvm/ADT/APInt.h"
#include "llvm/CodeGen/CallingConvLower.h"
#include "llvm/CodeGen/MachineFrameInfo.h"
#include "llvm/CodeGen/SelectionDAGNodes.h"
#include "llvm/Support/ErrorHandling.h"

using namespace llvm;

// Calling convention helpers generated by TableGen.
#include "SPEX64CallingConv.inc"

SPEX64TargetLowering::SPEX64TargetLowering(const SPEX64TargetMachine &TM,
                                           const SPEX64Subtarget &ST)
    : TargetLowering(TM, ST), ST(ST) {
  addRegisterClass(MVT::i64, &SPEX64::GPRRegClass);
  addRegisterClass(MVT::i32, &SPEX64::GPRRegClass);
  addRegisterClass(MVT::i16, &SPEX64::GPRRegClass);
  addRegisterClass(MVT::i8, &SPEX64::GPRRegClass);

  computeRegisterProperties(ST.getRegisterInfo());

  setOperationAction(ISD::Constant, MVT::i8, Promote);
  setOperationAction(ISD::Constant, MVT::i16, Promote);
  setOperationAction(ISD::ZERO_EXTEND, MVT::i8, Expand);
  setOperationAction(ISD::ZERO_EXTEND, MVT::i16, Expand);
  setOperationAction(ISD::ZERO_EXTEND, MVT::i32, Custom);
  setOperationAction(ISD::ZERO_EXTEND, MVT::i64, Custom);
  setOperationAction(ISD::SIGN_EXTEND, MVT::i8, Expand);
  setOperationAction(ISD::SIGN_EXTEND, MVT::i16, Expand);
  setOperationAction(ISD::SIGN_EXTEND, MVT::i32, Expand);
  setOperationAction(ISD::SIGN_EXTEND, MVT::i64, Expand);
  setOperationAction(ISD::ANY_EXTEND, MVT::i8, Expand);
  setOperationAction(ISD::ANY_EXTEND, MVT::i16, Expand);
  setOperationAction(ISD::ANY_EXTEND, MVT::i32, Expand);
  setOperationAction(ISD::ANY_EXTEND, MVT::i64, Expand);
  setOperationAction(ISD::BR, MVT::Other, Custom);
  setOperationAction(ISD::BR_CC, MVT::i8, Custom);
  setOperationAction(ISD::BR_CC, MVT::i16, Custom);
  setOperationAction(ISD::BR_CC, MVT::i32, Custom);
  setOperationAction(ISD::BR_CC, MVT::i64, Custom);

  setOperationAction(ISD::BRCOND, MVT::Other, Expand);
  setOperationAction(ISD::SETCC, MVT::i32, Expand);
  setOperationAction(ISD::SETCC, MVT::i64, Expand);
  setOperationAction(ISD::SELECT, MVT::i32, Expand);
  setOperationAction(ISD::SELECT, MVT::i64, Expand);
  setOperationAction(ISD::SELECT_CC, MVT::i32, Expand);
  setOperationAction(ISD::SELECT_CC, MVT::i64, Expand);

  setBooleanContents(ZeroOrOneBooleanContent);

  setTruncStoreAction(MVT::i64, MVT::i32, Expand);
  setTruncStoreAction(MVT::i64, MVT::i16, Expand);
  setTruncStoreAction(MVT::i64, MVT::i8, Expand);
  setTruncStoreAction(MVT::i32, MVT::i16, Expand);
  setTruncStoreAction(MVT::i32, MVT::i8, Expand);
  setTruncStoreAction(MVT::i16, MVT::i8, Expand);

  setLoadExtAction(ISD::ZEXTLOAD, MVT::i64, MVT::i8, Legal);
  setLoadExtAction(ISD::ZEXTLOAD, MVT::i64, MVT::i16, Legal);
  setLoadExtAction(ISD::ZEXTLOAD, MVT::i64, MVT::i32, Legal);
  setLoadExtAction(ISD::ZEXTLOAD, MVT::i32, MVT::i8, Legal);
  setLoadExtAction(ISD::ZEXTLOAD, MVT::i32, MVT::i16, Legal);
  setLoadExtAction(ISD::EXTLOAD, MVT::i64, MVT::i8, Legal);
  setLoadExtAction(ISD::EXTLOAD, MVT::i64, MVT::i16, Legal);
  setLoadExtAction(ISD::EXTLOAD, MVT::i64, MVT::i32, Legal);
  setLoadExtAction(ISD::EXTLOAD, MVT::i32, MVT::i8, Legal);
  setLoadExtAction(ISD::EXTLOAD, MVT::i32, MVT::i16, Legal);
  setLoadExtAction(ISD::SEXTLOAD, MVT::i64, MVT::i8, Legal);
  setLoadExtAction(ISD::SEXTLOAD, MVT::i64, MVT::i16, Legal);
  setLoadExtAction(ISD::SEXTLOAD, MVT::i64, MVT::i32, Legal);

  setOperationAction(ISD::GlobalAddress, MVT::i64, Custom);
  setOperationAction(ISD::ExternalSymbol, MVT::i64, Custom);
}

SDValue SPEX64TargetLowering::LowerOperation(SDValue Op,
                                             SelectionDAG &DAG) const {
  switch (Op.getOpcode()) {
  case ISD::BR:
    return LowerBR(Op.getOperand(0), Op.getOperand(1), SDLoc(Op), DAG);
  case ISD::BR_CC:
    return LowerBR_CC(
        Op.getOperand(0), cast<CondCodeSDNode>(Op.getOperand(1))->get(),
        Op.getOperand(2), Op.getOperand(3), Op.getOperand(4), SDLoc(Op), DAG);
  case ISD::ZERO_EXTEND: {
    // Prefer a single extending load when we see zext(load i8/i16/i32).
    SDValue Src = Op.getOperand(0);
    if (auto *LN = dyn_cast<LoadSDNode>(Src)) {
      EVT VT = Op.getValueType();
      EVT MemVT = LN->getMemoryVT();
      if ((VT == MVT::i32 || VT == MVT::i64) &&
          (MemVT == MVT::i8 || MemVT == MVT::i16 || MemVT == MVT::i32)) {
        // Keep the original memory operand information.
        return DAG.getExtLoad(ISD::ZEXTLOAD, SDLoc(Op), VT, LN->getChain(),
                              LN->getBasePtr(), MemVT, LN->getMemOperand());
      }
    }
    break;
  }
  case ISD::GlobalAddress: {
    auto *GA = cast<GlobalAddressSDNode>(Op);
    return DAG.getTargetGlobalAddress(GA->getGlobal(), SDLoc(Op),
                                      Op.getValueType(), GA->getOffset());
  }

  case ISD::ExternalSymbol: {
    auto *ES = cast<ExternalSymbolSDNode>(Op);
    return DAG.getTargetExternalSymbol(ES->getSymbol(), Op.getValueType(),
                                       ES->getTargetFlags());
  }

  default:
    break;
  }
  return SDValue();
}

SDValue SPEX64TargetLowering::LowerFormalArguments(
    SDValue Chain, CallingConv::ID CallConv, bool IsVarArg,
    const SmallVectorImpl<ISD::InputArg> &Ins, const SDLoc &DL,
    SelectionDAG &DAG, SmallVectorImpl<SDValue> &InVals) const {
  if (CallConv != CallingConv::C && CallConv != CallingConv::Fast)
    report_fatal_error("SPEX64: unsupported calling convention");
  if (IsVarArg)
    report_fatal_error("SPEX64: variadic arguments not supported");

  // Automatic lane synchronization for general function calls:
  //   lstop; lwait; call; (callee ret); lwake
  // Targets all lanes except the executing lane (self).
  Chain = DAG.getNode(SPEX64ISD::LSTOP, DL, MVT::Other, Chain);
  Chain = DAG.getNode(SPEX64ISD::LWAIT, DL, MVT::Other, Chain);


  // Automatic lane synchronization for general function calls:
  //   lstop; lwait; call; (callee ret); lwake
  // Targets all lanes except the executing lane (self).
  Chain = DAG.getNode(SPEX64ISD::LSTOP, DL, MVT::Other, Chain);
  Chain = DAG.getNode(SPEX64ISD::LWAIT, DL, MVT::Other, Chain);


  MachineFunction &MF = DAG.getMachineFunction();
  MachineRegisterInfo &MRI = MF.getRegInfo();

  SmallVector<CCValAssign, 16> ArgLocs;
  CCState CCInfo(CallConv, IsVarArg, MF, ArgLocs, *DAG.getContext());
  CCInfo.AnalyzeFormalArguments(Ins, CC_SPEX64);

  for (const CCValAssign &VA : ArgLocs) {
  EVT RegVT = VA.getLocVT();

  if (VA.isRegLoc()) {
    Register VReg = MRI.createVirtualRegister(&SPEX64::GPRRegClass);
    MRI.addLiveIn(VA.getLocReg(), VReg);
    SDValue ArgValue = DAG.getCopyFromReg(Chain, DL, VReg, RegVT);

    if (VA.getLocInfo() == CCValAssign::SExt)
      ArgValue = DAG.getNode(ISD::AssertSext, DL, RegVT, ArgValue,
                             DAG.getValueType(VA.getValVT()));
    else if (VA.getLocInfo() == CCValAssign::ZExt)
      ArgValue = DAG.getNode(ISD::AssertZext, DL, RegVT, ArgValue,
                             DAG.getValueType(VA.getValVT()));

    if (VA.getLocInfo() != CCValAssign::Full || RegVT != VA.getValVT())
      ArgValue = DAG.getNode(ISD::TRUNCATE, DL, VA.getValVT(), ArgValue);

    InVals.push_back(ArgValue);
    continue;
  }

  // Stack-passed argument: load from [SP + locmemoffset] at function entry.
  MachineFrameInfo &MFI = MF.getFrameInfo();
  int FI = MFI.CreateFixedObject(/*Size=*/8, VA.getLocMemOffset(),
                                 /*IsImmutable=*/true);
  SDValue FIN = DAG.getFrameIndex(FI, MVT::i64);
  SDValue Ld = DAG.getLoad(RegVT, DL, Chain, FIN,
                           MachinePointerInfo::getFixedStack(MF, FI));
  InVals.push_back(Ld);
  Chain = Ld.getValue(1);
}

return Chain;

}

SDValue
SPEX64TargetLowering::LowerReturn(SDValue Chain, CallingConv::ID, bool,
                                  const SmallVectorImpl<ISD::OutputArg> &Outs,
                                  const SmallVectorImpl<SDValue> &OutVals,
                                  const SDLoc &DL, SelectionDAG &DAG) const {
  if (Outs.size() > 1)
    report_fatal_error("SPEX64: only one return value is supported");

  if (!OutVals.empty()) {
    SDValue RetVal = OutVals[0];
    if (RetVal.getValueType() != MVT::i64)
      RetVal = DAG.getNode(ISD::ANY_EXTEND, DL, MVT::i64, RetVal);
    SDValue Glue;
    Chain = DAG.getCopyToReg(Chain, DL, SPEX64::RX, RetVal, Glue);
    Glue = Chain.getValue(1);
    return DAG.getNode(SPEX64ISD::RET, DL, MVT::Other, Chain, Glue);
  }

  return DAG.getNode(SPEX64ISD::RET, DL, MVT::Other, Chain);
}

SDValue SPEX64TargetLowering::LowerBR_CC(SDValue Chain, ISD::CondCode CC,
                                         SDValue LHS, SDValue RHS, SDValue Dest,
                                         const SDLoc &DL,
                                         SelectionDAG &DAG) const {
  auto ExtendTo = [&](SDValue V, MVT VT) -> SDValue {
    if (V.getValueType() == VT)
      return V;
    bool IsSigned = ISD::isSignedIntSetCC(CC);
    unsigned Opcode = IsSigned ? ISD::SIGN_EXTEND : ISD::ZERO_EXTEND;
    return DAG.getNode(Opcode, DL, VT, V);
  };

  MVT VT = (LHS.getValueType().getSizeInBits() <= 32 &&
            RHS.getValueType().getSizeInBits() <= 32)
               ? MVT::i32
               : MVT::i64;
  LHS = ExtendTo(LHS, VT);
  RHS = ExtendTo(RHS, VT);

  SDValue CCVal = DAG.getCondCode(CC);
  return DAG.getNode(SPEX64ISD::BR_CC, DL, MVT::Other, Chain, LHS, RHS, CCVal,
                     Dest);
}

SDValue SPEX64TargetLowering::LowerBR(SDValue Chain, SDValue Dest,
                                      const SDLoc &DL,
                                      SelectionDAG &DAG) const {
  return DAG.getNode(SPEX64ISD::BR, DL, MVT::Other, Chain, Dest);
}

SDValue
SPEX64TargetLowering::LowerCall(TargetLowering::CallLoweringInfo &CLI,
                                SmallVectorImpl<SDValue> &InVals) const {
  SelectionDAG &DAG = CLI.DAG;
  SDLoc DL(CLI.DL);
  SDValue Chain = CLI.Chain;
  SDValue Callee = CLI.Callee;
  CallingConv::ID CallConv = CLI.CallConv;

  if (CLI.IsTailCall)
    CLI.IsTailCall = false;

  if (CallConv != CallingConv::C && CallConv != CallingConv::Fast)
    report_fatal_error("SPEX64: unsupported calling convention");

  if (CLI.IsVarArg)
    report_fatal_error("SPEX64: variadic arguments not supported");

  // Automatic lane synchronization for general function calls:
  //   lstop; lwait; call; (callee ret); lwake
  // Targets all lanes except the executing lane (self).
  Chain = DAG.getNode(SPEX64ISD::LSTOP, DL, MVT::Other, Chain);
  Chain = DAG.getNode(SPEX64ISD::LWAIT, DL, MVT::Other, Chain);


  // Automatic lane synchronization for general function calls:
  //   lstop; lwait; call; (callee ret); lwake
  // Targets all lanes except the executing lane (self).
  Chain = DAG.getNode(SPEX64ISD::LSTOP, DL, MVT::Other, Chain);
  Chain = DAG.getNode(SPEX64ISD::LWAIT, DL, MVT::Other, Chain);




  // Automatic lane synchronization for general function calls:
  //   lstop; lwait; call; (callee ret); lwake
  // Targets all lanes except the executing lane (self).
  Chain = DAG.getNode(SPEX64ISD::LSTOP, DL, MVT::Other, Chain);
  Chain = DAG.getNode(SPEX64ISD::LWAIT, DL, MVT::Other, Chain);

  // Automatic lane synchronization for general function calls:
  //   lstop; lwait; call; (callee ret); lwake
  // Targets all lanes except the executing lane (self).
  Chain = DAG.getNode(SPEX64ISD::LSTOP, DL, MVT::Other, Chain);
  Chain = DAG.getNode(SPEX64ISD::LWAIT, DL, MVT::Other, Chain);

  // Automatic lane synchronization for general function calls:
  //   lstop; lwait; call; (callee ret); lwake
  // Targets all lanes except the executing lane (self).
  Chain = DAG.getNode(SPEX64ISD::LSTOP, DL, MVT::Other, Chain);
  Chain = DAG.getNode(SPEX64ISD::LWAIT, DL, MVT::Other, Chain);

  SmallVector<CCValAssign, 16> ArgLocs;
  CCState CCInfo(CallConv, CLI.IsVarArg, DAG.getMachineFunction(), ArgLocs,
                 *DAG.getContext());
  CCInfo.AnalyzeCallOperands(CLI.Outs, CC_SPEX64);

  unsigned NumBytes = CCInfo.getStackSize();
  Chain = DAG.getCALLSEQ_START(Chain, NumBytes, 0, DL);

  SmallVector<std::pair<unsigned, SDValue>, 4> RegsToPass;
  for (unsigned I = 0, E = ArgLocs.size(); I != E; ++I) {
    const CCValAssign &VA = ArgLocs[I];
    SDValue Arg = CLI.OutVals[I];

    switch (VA.getLocInfo()) {
    case CCValAssign::Full:
      break;
    case CCValAssign::SExt:
      Arg = DAG.getNode(ISD::SIGN_EXTEND, DL, VA.getLocVT(), Arg);
      break;
    case CCValAssign::ZExt:
      Arg = DAG.getNode(ISD::ZERO_EXTEND, DL, VA.getLocVT(), Arg);
      break;
    case CCValAssign::AExt:
      Arg = DAG.getNode(ISD::ANY_EXTEND, DL, VA.getLocVT(), Arg);
      break;
    default:
      llvm_unreachable("SPEX64: unknown argument extension");
    }

    if (VA.isRegLoc()) {
      RegsToPass.push_back({VA.getLocReg(), Arg});
      continue;
    }

    // Stack argument: store to outgoing call frame at [SP + LocMemOffset].
SDValue SPReg = DAG.getRegister(SPEX64::R63, MVT::i64);
int64_t Off = VA.getLocMemOffset();
SDValue Ptr = DAG.getNode(ISD::ADD, DL, MVT::i64, SPReg,
                          DAG.getConstant(Off, DL, MVT::i64));
Chain = DAG.getStore(Chain, DL, Arg, Ptr, MachinePointerInfo());
continue;

  }

  SDValue InGlue;
  for (const auto &RegArg : RegsToPass) {
    Chain = DAG.getCopyToReg(Chain, DL, RegArg.first, RegArg.second, InGlue);
    InGlue = Chain.getValue(1);
  }

  SDValue Target;
  switch (Callee.getOpcode()) {
  case ISD::TargetGlobalAddress:
    Target = Callee;
    break;
  case ISD::GlobalAddress: {
    auto *GA = cast<GlobalAddressSDNode>(Callee);
    Target = DAG.getTargetGlobalAddress(GA->getGlobal(), DL,
                                        getPointerTy(DAG.getDataLayout()),
                                        GA->getOffset(), GA->getTargetFlags());
    break;
  }
  case ISD::ExternalSymbol: {
    auto *ES = cast<ExternalSymbolSDNode>(Callee);
    Target = DAG.getTargetExternalSymbol(ES->getSymbol(),
                                         getPointerTy(DAG.getDataLayout()));
    break;
  }
  default:
    if (Callee.getValueType() != MVT::i64)
      Target = DAG.getNode(ISD::ANY_EXTEND, DL, MVT::i64, Callee);
    else
      Target = Callee;
    break;
  }

  SDVTList NodeTys = DAG.getVTList(MVT::Other, MVT::Glue);
  SmallVector<SDValue, 8> Ops;
  Ops.push_back(Chain);
  Ops.push_back(Target);

  const TargetRegisterInfo *TRI = ST.getRegisterInfo();
  const uint32_t *Mask =
      TRI->getCallPreservedMask(DAG.getMachineFunction(), CallConv);
  assert(Mask && "SPEX64: missing call preserved mask");
  Ops.push_back(DAG.getRegisterMask(Mask));

  for (const auto &RegArg : RegsToPass)
    Ops.push_back(DAG.getRegister(RegArg.first, RegArg.second.getValueType()));

  if (InGlue.getNode())
    Ops.push_back(InGlue);

  Chain = DAG.getNode(SPEX64ISD::CALL, DL, NodeTys, Ops);
  InGlue = Chain.getValue(1);

  Chain = DAG.getCALLSEQ_END(Chain, NumBytes, 0, InGlue, DL);
  InGlue = Chain.getValue(1);

  SDValue ResultChain = lowerCallResult(Chain, InGlue, DL, CLI.Ins, DAG, InVals);
  // Wake other lanes only after return values have been copied out.
  ResultChain = DAG.getNode(SPEX64ISD::LWAKE, DL, MVT::Other, ResultChain);
  return ResultChain;
}

SDValue SPEX64TargetLowering::lowerCallResult(
    SDValue Chain, SDValue InGlue, const SDLoc &DL,
    const SmallVectorImpl<ISD::InputArg> &Ins, SelectionDAG &DAG,
    SmallVectorImpl<SDValue> &InVals) const {
  if (Ins.empty())
    return Chain;
  if (Ins.size() > 1)
    report_fatal_error("SPEX64: multiple return values not supported");

  SDValue Copy = DAG.getCopyFromReg(Chain, DL, SPEX64::RX, MVT::i64, InGlue);
  Chain = Copy.getValue(1);
  SDValue Val = Copy;
  if (Ins[0].VT != MVT::i64)
    Val = DAG.getNode(ISD::TRUNCATE, DL, Ins[0].VT, Val);
  InVals.push_back(Val);

  return Chain;
}
