//===- SPEX64AsmParser.cpp - Parse SPEX64 assembly ------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#include "../MCTargetDesc/SPEX64MCTargetDesc.h"
#include "../TargetInfo/SPEX64TargetInfo.h"
#include "llvm/ADT/APInt.h"
#include "llvm/ADT/StringRef.h"
#include "llvm/MC/MCAsmInfo.h"
#include "llvm/MC/MCContext.h"
#include "llvm/MC/MCExpr.h"
#include "llvm/MC/MCInst.h"
#include "llvm/MC/MCInstrInfo.h"
#include "llvm/MC/MCParser/AsmLexer.h"
#include "llvm/MC/MCParser/MCParsedAsmOperand.h"
#include "llvm/MC/MCParser/MCTargetAsmParser.h"
#include "llvm/MC/MCStreamer.h"
#include "llvm/MC/MCSubtargetInfo.h"
#include "llvm/MC/TargetRegistry.h"
#include "llvm/Support/Casting.h"
#include "llvm/Support/Compiler.h"
#include "llvm/Support/Debug.h"

#define DEBUG_TYPE "spex64-asm-parser"

using namespace llvm;

namespace {

// Auto-generated by TableGen
static MCRegister MatchRegisterName(StringRef Name);

class SPEX64Operand : public MCParsedAsmOperand {
  enum KindTy { k_Token, k_Reg, k_Imm } Kind;
  SMLoc StartLoc;
  SMLoc EndLoc;
  StringRef Tok;
  unsigned Reg = 0;
  const MCExpr *Imm = nullptr;

public:
  SPEX64Operand(KindTy Kind, SMLoc StartLoc, SMLoc EndLoc)
      : Kind(Kind), StartLoc(StartLoc), EndLoc(EndLoc) {}

  bool isToken() const override { return Kind == k_Token; }
  bool isReg() const override { return Kind == k_Reg; }
  bool isImm() const override { return Kind == k_Imm; }
  bool isExpr() const {
    // Symbolic immediates are represented as MCExpr (non-constant) while still
    // using the k_Imm operand kind.
    return isImm() && Imm && !isa<MCConstantExpr>(Imm);
  }

  bool isMem() const override { return false; }
  StringRef getToken() const { return Tok; }

  bool isImm9() const {
    if (!isImm())
      return false;
    auto *CE = dyn_cast<MCConstantExpr>(Imm);
    if (!CE)
      return false;
    int64_t Val = CE->getValue();
    return isUInt<9>(Val);
  }

  bool isImm32() const {
    if (!isImm())
      return false;
    auto *CE = dyn_cast<MCConstantExpr>(Imm);
    if (!CE)
      return true;
    int64_t Val = CE->getValue();
    return isInt<32>(Val);
  }

  bool isImm64() const {
    // Accept both numeric immediates and symbol expressions (e.g. call foo).
    if (isImm())
      return true;
    if (isExpr())
      return true;
    return false;
  }

  MCRegister getReg() const override { return Reg; }
  const MCExpr *getImm() const { return Imm; }

  void addRegOperands(MCInst &Inst, unsigned N) const {
    assert(N == 1 && "invalid number of operands");
    Inst.addOperand(MCOperand::createReg(Reg));
  }

  void addImmOperands(MCInst &Inst, unsigned N) const {
    assert(N == 1 && "invalid number of operands");
    if (auto *CE = dyn_cast<MCConstantExpr>(Imm))
      Inst.addOperand(MCOperand::createImm(CE->getValue()));
    else
      Inst.addOperand(MCOperand::createExpr(Imm));
  }

  static std::unique_ptr<SPEX64Operand> createToken(StringRef Tok, SMLoc Loc) {
    auto Op = std::make_unique<SPEX64Operand>(k_Token, Loc, Loc);
    Op->Tok = Tok;
    return Op;
  }

  static std::unique_ptr<SPEX64Operand> createReg(unsigned Reg, SMLoc StartLoc,
                                                  SMLoc EndLoc) {
    auto Op = std::make_unique<SPEX64Operand>(k_Reg, StartLoc, EndLoc);
    Op->Reg = Reg;
    return Op;
  }

  static std::unique_ptr<SPEX64Operand>
  createImm(const MCExpr *Imm, SMLoc StartLoc, SMLoc EndLoc) {
    auto Op = std::make_unique<SPEX64Operand>(k_Imm, StartLoc, EndLoc);
    Op->Imm = Imm;
    return Op;
  }

  void print(raw_ostream &OS, const MCAsmInfo &MAI) const override {
    switch (Kind) {
    case k_Token:
      OS << "Tok:" << Tok;
      break;
    case k_Reg:
      OS << "Reg:" << Reg;
      break;
    case k_Imm:
      OS << "Imm";
      break;
    }
  }

  SMLoc getStartLoc() const override { return StartLoc; }
  SMLoc getEndLoc() const override { return EndLoc; }
};

class SPEX64AsmParser : public MCTargetAsmParser {
  MCAsmParser &Parser;

#define GET_ASSEMBLER_HEADER
#include "SPEX64GenAsmMatcher.inc"

  MCAsmParser &getParser() const { return Parser; }
  AsmLexer &getLexer() const { return Parser.getLexer(); }

  bool parseImm(OperandVector &Operands) {
    SMLoc StartLoc = getLexer().getLoc();

    if (getLexer().is(AsmToken::Hash) || getLexer().is(AsmToken::At))
      getLexer().Lex();

    const MCExpr *Expr = nullptr;
    if (Parser.parseExpression(Expr))
      return Error(StartLoc, "invalid immediate");

    SMLoc EndLoc = getLexer().getLoc();
    Operands.push_back(SPEX64Operand::createImm(Expr, StartLoc, EndLoc));
    return false;
  }

  bool parseMemOperand(OperandVector &Operands) {
    SMLoc StartLoc = getLexer().getLoc();
    getLexer().Lex(); // '['
    Operands.push_back(SPEX64Operand::createToken("[", StartLoc));

    if (getLexer().isNot(AsmToken::Identifier) ||
        getLexer().getTok().getIdentifier().lower() != "rx") {
      return Error(StartLoc, "expected rx in memory operand");
    }
    AsmToken const &RegTok = getParser().getTok();
    MCRegister Reg = MatchRegisterName(RegTok.getIdentifier().lower());
    if (Reg == SPEX64::NoRegister)
      return Error(StartLoc, "invalid register in memory operand");
    getLexer().Lex(); // eat rx
    Operands.push_back(
        SPEX64Operand::createReg(Reg, RegTok.getLoc(), RegTok.getEndLoc()));

    if (getLexer().is(AsmToken::RBrac)) {
      SMLoc EndLoc = getLexer().getLoc();
      getLexer().Lex();
      Operands.push_back(SPEX64Operand::createToken("]", EndLoc));
      return false; // no offset operand
    }

    bool IsMinus = false;
    if (getLexer().is(AsmToken::Plus)) {
      Operands.push_back(SPEX64Operand::createToken("+", getLexer().getLoc()));
      getLexer().Lex();
    } else if (getLexer().is(AsmToken::Minus)) {
      IsMinus = true;
      Operands.push_back(SPEX64Operand::createToken("+", getLexer().getLoc()));
      getLexer().Lex();
    } else {
      return Error(StartLoc, "expected + or - in memory operand");
    }

    const MCExpr *Expr = nullptr;
    if (Parser.parseExpression(Expr))
      return Error(StartLoc, "invalid memory offset");

    if (IsMinus)
      Expr = MCUnaryExpr::createMinus(Expr, Parser.getContext());

    // Keep the immediate *inside* the brackets: [ rx + imm ]
    SMLoc ImmEndLoc = getLexer().getLoc();
    Operands.push_back(SPEX64Operand::createImm(Expr, StartLoc, ImmEndLoc));

    if (getLexer().isNot(AsmToken::RBrac))
      return Error(StartLoc, "expected ]");
    SMLoc EndLoc = getLexer().getLoc();
    getLexer().Lex();
    Operands.push_back(SPEX64Operand::createToken("]", EndLoc));
    return false;
  }

  bool matchAndEmitInstruction(SMLoc IDLoc, unsigned &Opcode,
                               OperandVector &Operands, MCStreamer &Out,
                               uint64_t &ErrorInfo,
                               bool MatchingInlineAsm) override {
    MCInst Inst;
    unsigned MatchResult =
        MatchInstructionImpl(Operands, Inst, ErrorInfo, MatchingInlineAsm);
    switch (MatchResult) {
    case Match_Success:
      Out.emitInstruction(Inst, getSTI());
      return false;
    case Match_MissingFeature:
      return Error(IDLoc,
                   "instruction requires a feature not currently enabled");
    case Match_InvalidOperand:
      return Error(IDLoc, "invalid operand");
    case Match_InvalidTiedOperand:
      return Error(IDLoc, "invalid tied operand");
    default:
      return Error(IDLoc, "invalid instruction");
    }
  }

  bool parseRegister(MCRegister &Reg, SMLoc &StartLoc, SMLoc &EndLoc) override {
    ParseStatus Res = tryParseRegister(Reg, StartLoc, EndLoc);
    if (Res.isFailure())
      return Error(StartLoc, "invalid register name");
    if (Res.isSuccess())
      return false;
    return true;
  }

  ParseStatus tryParseRegister(MCRegister &Reg, SMLoc &StartLoc,
                               SMLoc &EndLoc) override {
    if (getLexer().getKind() == AsmToken::Identifier) {
      auto Name = getLexer().getTok().getIdentifier().lower();
      Reg = MatchRegisterName(Name);
      if (Reg == SPEX64::NoRegister)
        return ParseStatus::NoMatch;

      AsmToken const &T = getParser().getTok();
      StartLoc = T.getLoc();
      EndLoc = T.getEndLoc();
      getLexer().Lex();
      return ParseStatus::Success;
    }

    return ParseStatus::NoMatch;
  }

  bool parseOperand(OperandVector &Operands) {
    if (getLexer().is(AsmToken::LBrac))
      return parseMemOperand(Operands);

    MCRegister RegNo;
    SMLoc StartLoc, EndLoc;
    ParseStatus Res = tryParseRegister(RegNo, StartLoc, EndLoc);
    if (Res.isSuccess()) {
      Operands.push_back(SPEX64Operand::createReg(RegNo, StartLoc, EndLoc));
      return false;
    }

    if (getLexer().is(AsmToken::Hash) || getLexer().is(AsmToken::At) ||
        getLexer().is(AsmToken::Integer) ||
        getLexer().is(AsmToken::Identifier) || getLexer().is(AsmToken::Minus)) {
      return parseImm(Operands);
    }

    return Error(getLexer().getLoc(), "unexpected token in operand");
  }

  bool parseInstruction(ParseInstructionInfo &Info, StringRef Name,
                        SMLoc NameLoc, OperandVector &Operands) override {
    // Accept mnemonic suffix written with a '-' (e.g. "bcc-eq").
    // The LLVM asm lexer tokenizes this as: Identifier("bcc"), Minus,
    // Identifier("eq"). Recompose it here so the TableGen asm matcher sees a
    // single mnemonic token.
    if (getLexer().is(AsmToken::Minus)) {
      AsmToken TokAfterDash = getLexer().peekTok();
      if (TokAfterDash.is(AsmToken::Identifier)) {
        SmallString<32> FullName(Name);
        FullName.push_back('-');
        FullName.append(TokAfterDash.getIdentifier());
        // Consume '-' and the suffix identifier.
        getLexer().Lex(); // '-'
        getLexer().Lex(); // suffix
        Name = Parser.getContext().allocateString(FullName);
      }
    }

    Operands.push_back(SPEX64Operand::createToken(Name, NameLoc));

    if (getLexer().is(AsmToken::EndOfStatement))
      return false;

    while (true) {
      if (parseOperand(Operands))
        return true;

      if (getLexer().is(AsmToken::EndOfStatement))
        break;
      if (getLexer().isNot(AsmToken::Comma))
        return Error(getLexer().getLoc(), "expected ','");
      getLexer().Lex();
    }

    return false;
  }

  unsigned validateTargetOperandClass(MCParsedAsmOperand &Op,
                                      unsigned Kind) override {
    return Match_InvalidOperand;
  }

public:
  SPEX64AsmParser(const MCSubtargetInfo &STI, MCAsmParser &Parser,
                  const MCInstrInfo &MII, const MCTargetOptions &Options)
      : MCTargetAsmParser(Options, STI, MII), Parser(Parser) {
    setAvailableFeatures(STI.getFeatureBits());
  }
};

#define GET_REGISTER_MATCHER
#define GET_MATCHER_IMPLEMENTATION
#include "SPEX64GenAsmMatcher.inc"

} // end anonymous namespace

extern "C" LLVM_EXTERNAL_VISIBILITY void LLVMInitializeSPEX64AsmParser() {
  RegisterMCAsmParser<SPEX64AsmParser> X(getTheSPEX64Target());
}
